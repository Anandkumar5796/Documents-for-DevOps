**Docker overview**

Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Dockerâ€™s methodologies for shipping, testing, and deploying code, you can significantly reduce the delay between writing code and running it in production.

**Docker Commands**

1.docker version : Displays Docker version information, including the client and server versions.

2.docker info : Provides detailed information about the Docker installation, such as the number of containers, images, storage drivers, and more.

3.docker pull <image> : Downloads a Docker image from a registry (like Docker Hub) to your local machine. The image is used as a base for creating containers.

4.docker images : Lists all Docker images available on your local machine, along with their sizes and tags.

5.docker build -t <tag> <path> : Builds a Docker image from a Dockerfile located in the specified path and assigns it a given tag.

6.docker run <image> : Creates and starts a new container from the specified image. If the image is not available locally, Docker will try to pull it first.

7.docker ps : Lists all running containers along with their details, including container IDs, names, status, and ports.

8.docker ps -a : Lists all containers, including those that are not currently running.

9.docker exec -it <container> <command> : Runs a command inside a running container. The -it flag allows interaction with the command's input and output streams.

10.docker stop <container> : Stops a running container gracefully, giving it a chance to perform any necessary cleanup before shutting down.

11.docker start <container> : Starts a stopped container that was previously created but is not currently running.

12.docker restart <container> : Stops and then starts a container, effectively restarting it.

13.docker logs <container> : Displays the logs generated by a container, helping you troubleshoot issues or monitor application output.

14.docker rm <container> : Removes a stopped container. The -f flag can be used to force removal of a running container.

15.docker rmi <image> : Removes a Docker image from your local machine. The -f flag can be used to force removal of an image.

16.docker-compose up : Starts services defined in a docker-compose.yml file. It creates and starts containers for all services, based on the configurations provided.

17.docker-compose down : Stops and removes containers, networks, and volumes defined in a docker-compose.yml file.



**Dockerfile instructions**

FROM : This instruction specifies the base image from which you want to build your image. It's the starting point for your Docker image.
Example:
FROM ubuntu:20.04

RUN : instruction allows you to execute commands within the container during the image build process. These commands are typically used to install software packages, update packages, and set up configurations.
Example:
RUN apt-get update && apt-get install -y curl

COPY and ADD : The COPY instruction copies files or directories from the host machine to the container's filesystem. The ADD instruction is similar but has additional features, such as extracting compressed files.
Example:
COPY app.py /app/

EXPOSE : The EXPOSE instruction documents the ports that a container will listen on at runtime. It doesn't actually expose the ports, but it's useful for documentation purposes.
Example:
EXPOSE 80

CMD and ENTRYPOINT : These instructions define the command that will be executed when a container is run from the image. CMD provides default arguments to the command, and ENTRYPOINT specifies the executable that should be run.
Example:
CMD ["python", "app.py"]

ENV : The ENV instruction sets environment variables within the container. This is useful for providing configuration values to your application.
Example:
ENV DB_HOST=localhost DB_PORT=5432

RUNTIME : The RUNTIME instruction sets metadata about the image's behavior at runtime. For example, USER sets the user context for the image, and VOLUME designates a directory as a volume.
Example:
USER nonrootuser
VOLUME /data

ENTRYPOINT : The ENTRYPOINT instruction in a Dockerfile specifies the command to run when a container starts from the image. It essentially defines the default executable for the container. Any arguments passed to docker run will be appended to the ENTRYPOINT command.
Example:
ENTRYPOINT ["python", "app.py"]

**Dockerfile Example**

Use an official Node.js runtime as the base image
FROM node:14

Set the working directory inside the container
WORKDIR /usr/src/app

Copy package.json and package-lock.json to the working directory
COPY package*.json ./

Install application dependencies
RUN npm install

Copy the rest of the application code into the container
COPY . .

Expose a port that the application will listen on
EXPOSE 3000

Define the command to run when the container starts
CMD ["node", "app.js"]


**Docker-Compose Commands instructions**

docker-compose up : This command starts your application and all the services defined in your docker-compose.yml file. It creates and attaches to the necessary containers, networks, and volumes.

docker-compose down : This command stops and removes the containers, networks, and volumes defined in your docker-compose.yml file. It effectively shuts down your application.

docker-compose build : This command builds the Docker images defined in your docker-compose.yml file. It's useful when you've made changes to your Dockerfiles or other build-related files.

docker-compose ps : This command shows the status of the containers defined in your docker-compose.yml file. It displays information about each service, including container names, status, and ports.

docker-compose logs : This command displays the logs generated by the containers in your application. You can specify a service name to view logs for a specific service.

docker-compose exec : This command lets you execute a command in a running container. You specify the service name and the command you want to run.

docker-compose run : Similar to docker-compose exec, this command lets you run a one-off command in a new container instance. It's often used for running tests or ad-hoc commands.

**Docker-Compose file instructions**

version: Specifies the version of the Compose file format being used.

services : Defines the individual services (containers) that make up your application.
    image : Specifies the Docker image to use for the service.
    build : Specifies the build context and Dockerfile for building a custom image.
    command : Overrides the default command specified in the Docker image.
    environment : Sets environment variables for the service.
    volumes : Defines volume mounts for the service.
    ports : Specifies ports to be exposed by the service.
    networks : Associates the service with specific networks.

networks: Defines networks that containers will connect to.

volumes: Defines volumes that containers can use to store data.

configs (Docker Swarm only): Defines configuration files to be used by services.

secrets (Docker Swarm only): Defines secrets to be used by services.

secrets (Docker Swarm only): Defines secrets to be used by services.

deploy (Docker Swarm only): Specifies deployment-related settings for services.

version: Specifies the version of the Compose file format being used.

**Docker-Compose file Example**

version: '3'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DEBUG=true
    volumes:
      - ./app/src:/app/src
networks:
  mynetwork:
    driver: bridge
